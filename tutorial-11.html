<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="perihelion of poSTmortem">
<title>Of Making The Mountain Move To Mohammed</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<a href="." style="position: absolute; top: .5rem; left: .5rem;">Index</a>
<a href="https://github.com/nguillaumin/perihelion-m68k-tutorials"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</head>
<body class="article">
<div id="header">
<h1>Of Making The Mountain Move To Mohammed</h1>
<div class="details">
<span id="author" class="author">perihelion of poSTmortem</span><br>
<span id="revdate">2002-07-12 (last edition of the initial revision)</span>
</div>
</div>
<div id="content">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Is it possible that we two, you and I, have grown so old and
inflexible that we have outlived our usefulness? Would that
constitute &#8230;&#8203; a joke?</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Star Trek VI<br>
<cite>the Undiscovered Country</cite>
</div>
</div>
<div class="paragraph">
<p>Well well, finally, as promised, we will delve into the technique of sprites; the essence of a
platform or shoot-em-up game, and lots of other stuff. In fact, anything that needs
something moving that is not 3D or real time rendered (that is, it&#8217;s being drawn while the
program runs, and not stored previously as a picture). It was really challenging and great fun
to code this one, and it&#8217;s probably the most satisfying coding experience ever, I hope I can
convey the knowledge it brought me.</p>
</div>
<div class="paragraph">
<p>In the last tutorial, we learned something on pixels, in order to be able to address a single
pixel anywhere, the data must be shifted into a correct position. Why is this? Because, each
instruction except the bit instructions, deal with at least byte size. What it means is that if we
use instructions with byte size, all pixels "snap" at 8 pixels, because that&#8217;s the minimum
addressable size. However, by shifting the data before using it in graphic instructions, we can
in a way address any pixel we want to.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/tutorial-11-autumn.gif" alt="tutorial 11 autumn">
</div>
<div class="title">Figure 1. autumn.pi1</div>
</div>
<div class="paragraph">
<p>I actually suggest you load up the pre-assembled program, and both the picture files that
comes with the tutorials, the pictures being <code>autumn.pi1</code> and <code>sprite.pi1</code>. A little note on the
pictures, they are in STe palette, meaning that they will look a bit ugly on a ST, but STeem
should handle this nicely. Yes, the character seen is the same one as in <a href="tutorial-09.html">tutorial 9</a>:
Kenshin. He&#8217;s the main character in a Japanimation, a former assassin for the government who now tries to
atone by living a quiet life and helping people. This series is awesome and has given me
much inspiration, the first Kenshin OVA series is one of the most beautiful pieces of art I&#8217;ve
ever seen.</p>
</div>
<div id="sprite" class="imageblock">
<div class="content">
<img src="img/tutorial-11-sprite.gif" alt="tutorial 11 sprite">
</div>
<div class="title">Figure 2. sprite.pi1</div>
</div>
<div class="paragraph">
<p>So, after you&#8217;ve been impressed by the Tai Ji symbol (a.k.a. Yin and Yang symbol, Yin and Yo
in Japanese) bouncing around the screen, you are eager to learn for yourself, right? As you
can see, the background is provided in the <code>autumn.pi1</code>, and the bouncing ball, which is the
sprite, is in <code>sprite.pi1</code>. Actually, only 14 colours are used for the background, the last two
being reserved for the sprite, this isn&#8217;t necessary and the sprite may well share colours with
the background. The sprite seems to appear twice, in the <code>sprite.pi1</code>, there are two balls,
one of them is the sprite mask, if confusion occurs, just read on.</p>
</div>
<div class="paragraph">
<p>Painting the background is easy, just smack in the pixel data and set the palette, bouncing
will be dealt with later, what we need to focus on now is getting the sprite nicely on the
screen, and being able to put it anywhere on the screen, preferably expressing the location in
X and Y coordinates for human compatibility. How exactly to put the sprite data on screen,
the most obvious choice is a <code>move</code> instruction. This won&#8217;t do at all though, check this out.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Screen memory</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00001110</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00001011</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%01010101</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Pixel colours</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$0808595C</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Sprite data</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000001</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00100000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00001010</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Pixel colours</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00208081</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Now, if we move the sprite data onto the graphics memory, we get</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Screen memory</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000001</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00100000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00001010</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Pixel colours</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00208081</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Move instructions destroy all data and replace it with new, in other words, the background is
completely lost and the sprite has taken over completely. Doing it like this will also create an
ugly squared looking sprite, since the sprite background will not be transparent (actually
rectangular, but more on this below), as you can see on <a href="#moving-data">Result of simply <code>move</code>'ing the sprite data"</a>. This will not do.</p>
</div>
<div id="moving-data" class="imageblock">
<div class="content">
<img src="img/tutorial-11-block.gif" alt="tutorial 11 block">
</div>
<div class="title">Figure 3. Result of simply <code>move</code>'ing the sprite data"</div>
</div>
<div class="paragraph">
<p>OR instructions, on the other hand, will not overwrite the original data, we try an OR
instruction with the above configuration.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Screen memory</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00001111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00100000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00001011</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%01011111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Pixel colours</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$0828D9DD</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Dang! By ORing in the sprite, we mixed the sprite with the background, this is also bad since
the sprite will not look as it should, although it will create quite a nice effect and is good if
you simply want a "colour distortion" effect, but we don&#8217;t want that now (check <a href="#or-ing">Using an OR instead</a> to
see the effect). An EOR would only flip the colours around in strange ways (<a href="#eor-ing">An EOR is also no good&#8230;&#8203;</a>), and an
AND instruction clears data (<a href="#and-ing">"&#8230;&#8203;as it isn&#8217;t an AND either"</a>).</p>
</div>
<div id="or-ing" class="imageblock">
<div class="content">
<img src="img/tutorial-11-or.gif" alt="tutorial 11 or">
</div>
<div class="title">Figure 4. Using an OR instead</div>
</div>
<div id="eor-ing" class="imageblock">
<div class="content">
<img src="img/tutorial-11-eor.gif" alt="tutorial 11 eor">
</div>
<div class="title">Figure 5. An EOR is also no good&#8230;&#8203;</div>
</div>
<div id="and-ing" class="imageblock">
<div class="content">
<img src="img/tutorial-11-and.gif" alt="tutorial 11 and">
</div>
<div class="title">Figure 6. "&#8230;&#8203;as it isn&#8217;t an AND either"</div>
</div>
<div class="paragraph">
<p>But wait, if we clear out the sprite data, with an AND, leaving the background intact, and
then OR in the sprite, it would all work. The sprite mask has the same look as the sprite, but
is only two colours. Colour 15 where the background is, making sure all bits there are set,
and colour 0 where the real sprite form is, making sure all bits are cleared. Have a look at
<a href="#sprite">sprite.pi1</a> and you will see clearly (well, ok, in the picture, the mask
is colour 15 and the background is colour 0, but it will get inverted later, read on&#8230;&#8203; ).</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Sprite mask</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11111111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11010100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11111111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11010100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11111111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11010100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11111111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%11010100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Pixel colours</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$FFFFFFFF</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$FF0F0F00</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All pixels that were colour 0 (background) in the sprite, are now colour 15 (<code>F</code>), and all pixels
that had one colour or another in the sprite are now colour 0. By ANDing the sprite mask with
the background, we will make sure to clear out all sprite pixels (since they get ANDed with 0)
and keeping the status of all other bits (since they are ANDed with 1). It is imperative that
you understand this step, if you don&#8217;t, reread the Boolean algebra part in <a href="tutorial-09.html">tutorial 9</a>
check some external sources and think again, or send me an e-mail ☺. After applying the
mask, the screen memory will look like this:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Screen memory</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%01010100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Pixel colours</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$08080900</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">#bbbbbbbb</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">#bbsbsbss</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">b=background, s=sprite</p></td>
</tr>
</tbody>
</table>
<div id="mask" class="imageblock">
<div class="content">
<img src="img/tutorial-11-mask.gif" alt="tutorial 11 mask">
</div>
<div class="title">Figure 7. What the screen looks like, after the mask is applied.</div>
</div>
<div class="paragraph">
<p>As you can see (also in <a href="#mask">What the screen looks like, after the mask is applied.</a>), the background has been preserved, while everything
concerning the sprite is wiped out. Now is the time to OR in the sprite data: this instruction
will in no way affect the background (since the background colour in the sprite is 0). This is
what it will look like after the OR operation:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Screen memory</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000101</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00100000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%01011110</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth word</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Pixel colours</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000000</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$08288981</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">#bbbbbbbb</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">#bbsbsbss</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">b=background, s = sprite</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>To summarise: first we take an inverted version of our sprite with only two colours, and AND
that with the background. This clears all pixels that are concerned with the sprite and leaves
the background intact. After the mask is applied, it is safe to OR in the sprite data, since after
the previous clearing of the sprite pixels, there is no risk of mixing the sprite with the
background. The background in the sprite is colour 0, thus the OR instruction will have no
effect on the background, the background part in the mask is colour 15 (all 1&#8217;s) and thus the
AND instruction will not affect the background.</p>
</div>
<div class="paragraph">
<p>OK, now we know how to put the sprite on screen, but we are still faced with the problem of
not being able to put it anywhere. To solve this, the sprite and mask data must be shifted.
Like with the putpixel, in order to put the sprite at say 0,2, we need to shift the sprite data
right two bits. With the putpixel, we shifted "real time", but there is much more data involved
in a sprite, so we&#8217;ll be pre-shifting the sprite instead. When using the pre-shifted method, we
assign a storage area that is 16 times larger than the sprite data, and store the sprite in that
area shifted in all possible sixteen combinations we need.</p>
</div>
<div class="paragraph">
<p>I see a big <code>?</code> in your face right now. Think about it, in the putpixel routine, we could end up
shifting the pixel 15 bits to the right, at most, so what we do here with the sprite is to store
all those possibilities after one another. When the time comes to put the sprite out, instead of
shifting the original sprite data, all we have to do is access the storage area with the correct
offset. An offset is the value added to the starting address of something. For example, the
middle of the screen is the screen address with an offset of 100 × 160 + 80 = 16080 bytes.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Sprite data</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00001111</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Sprite storage area</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00001111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first position, offset 0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000111</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second position, offset 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000011</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third position, offset 2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">$00000001</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">fourth position, offset 3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">(the offset number is completely fictional, it&#8217;s not even an even number)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Let&#8217;s say we want to put the sprite at 0,2, we know what that means, it means point to the
start of the screen memory, shift the sprite data right by 2, and put it in place. Say <code>a0</code> points
to the screen memory, and <code>a1</code> to the sprite storage area, then we just need to add offset 2 to
<code>a1</code>, and a1 will point to correctly shifted sprite data. Pre-shifting is way faster than loading up
the sprite data in <code>a1</code>, and then shifting it, especially since the sprite data consists of several
words that all need to be shifted. The downside of course is loss of memory.</p>
</div>
<div class="paragraph">
<p>Now, there is a problem here, if we have a 32×32 pixel sprite, like in the sample program, the
data for the sprite is 16×32 bytes, arranged like this:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">Sprite data (W = word)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">First 16 pixels</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Last 16 pixels</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first line</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second line</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third line</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">&#8230;&#8203; and so on for a total of 32 lines</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When we begin to shift, we want the last bit that go out the first word, to be shifted in as the
first bit in the fifth word. This is comparable to the tutorials on scrolling. The last bit that goes
out the fifth word, should not go into the first bit of the ninth word, because then a pixel
from the first line would go into the second line, but there is no room to shift it out right on
the first line. So, we have to add a buffer to every line so that no data will be lost in the shift.
In the last shift, the first four words will be all but empty, and the buffer will be all but full. So
the sprite storage area will have to look like this.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="4">Sprite storage area (B=buffer, word size)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">First 16 pixels</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Middle 16 pixels</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Last 16 pixels</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">BBBB</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">first line</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">BBBB</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">second line</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WWWW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">BBBB</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">third line</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">&#8230;&#8203; and so on for a total of 32 lines and 16 such blocks to cover all possible shifts</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">FIXME</div>
<div class="paragraph">
<p>tut11blk.prg below</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even though the sprite storage area covers a total of 48 pixels, 16 of these will be 0, thus not
affecting the background. See the sprite as a 48 pixel wide block, with only 32 pixels
coloured. Within this 48 pixel block, the 32 colour pixels will be shifted more and more to the
right as X coordinates increase, then when it becomes critical, the block will move 16 pixels to
the right in one sweep, and the 32 pixel colour area will be reset, starting the procedure all
over again. Run the <code>tut11blk.prg</code>, to see this clear.</p>
</div>
<div class="paragraph">
<p>Alright, theory part on pre-shifting done, now we need it in direct coding practice as well.
First off, we&#8217;ll need a good instruction with which to shift. Sure, <code>lsr</code> seems a good choice,
but we need to be able to preserve the bit that gets shifted out, and <code>lsr</code> doesn&#8217;t preserve
anything. The instruction <code>roxr</code>, for <strong>RO</strong>tate e<strong>X</strong>tended <strong>R</strong>ight, is good in this case. The
extended bit is rotated in from the left, and the bit rotated out the right is saved in the carry
and extended flag. So, by `roxr`ing with one each time, we will save what we shift out, and
shift it in the next time around (btw, when speaking about the user bits in the status register,
flags and bits are used synonymous). Looki looki:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">d0</th>
<th class="tableblock halign-center valign-top">X (extended bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00001101</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>roxr #1,d0</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%00000110</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>roxr #1,d0</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%10000011</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>roxr #1,d0</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">%01000001</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>What we do is to first copy the sprite data to the sprite storage area, then we take the data
from the storage area, rotate extended right with one, and save that data into the next
position of the storage area. What we have to think about when coding this is that the data
from the first word, goes into the fifth word and so on. In code, it looks like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>                move.l  #spr_dat, a0             ; original sprite data
                add.l   #34, a0                  ; skip palette
                move.l  #sprite, a1              ; storage of pre-shifted sprite

                move.l  #32-1, d0                ; 32 scan lines per sprite
first_sprite
                move.l  (a0)+, (a1)+             ; move from original to pre-shifted
                move.l  (a0)+, (a1)+
                move.l  (a0)+, (a1)+
                move.l  (a0)+, (a1)+             ; 32 pixels moved
                add.l   #8, a1                   ; jump over end words
                add.l   #144, a0                 ; jump to next scan line
                dbf     d0, first_sprite</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, point to the sprite data, jump over the palette and load up the sprite storage area,
which is a <code>ds.l 3072</code>: 16 bytes per line, plus 8 for the buffer, totalling 24 bytes per scan
line. The sprite is 32 lines and there should be 16 such blocks. This adds up to 24 × 32 × 16 =
12288 bytes, which is 3072 long words. In the loop, just copy data from the sprite picture to
the storage area, the buffer word area is skipped since it contains nothing at this time. Now
comes the challenging part, writing the generic pre-shift.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>                move.l  #sprite, a0              ; point to beginning of storage area
                move.l  #sprite, a1              ; point to beginning of storage area
                add.l   #768, a1                 ; point to next sprite position

                move.l  #15-1, d1                ; 15 sprite positions left
positions
                move.l  #32-1, d2                ; 32 scan lines per sprite
line
                move.l  #4-1, d3                 ; 4 bit planes
plane
                move.w  (a0), d0                 ; move one word
                roxr    #1, d0                   ; pre-shift
                move.w  d0, (a1)                 ; put it in place
                move.w  8(a0), d0                ; move one word
                roxr    #1, d0                   ; pre-shift
                move.w  d0, 8(a1)                ; put it in place

                move.w  16(a0), d0               ; move one word
                roxr    #1, d0                   ; pre-shift
                move.w  d0, 16(a1)               ; put it in place

                add.l   #2, a0                   ; next bit plane, also clears X flag
                add.l   #2, a1                   ; next bit plane

                dbf     d3, plane

                add.l   #16, a1                  ; next scan line
                add.l   #16, a0                  ; next scan line

                dbf     d2, line

                dbf     d1, positions</code></pre>
</div>
</div>
<div class="paragraph">
<p>First off, load up the storage area in <code>a0</code> and <code>a1</code>, and make a1 point to the next storage area.
This one is empty and should contain the sprite data shifted one bit to the right. Since we
have already filled the first position in the storage area, 15 positions are left. 32 lines to each
sprite and 4 bit planes to each line. Since all these are treated the same way, we only need
one big loop so to speak.</p>
</div>
<div class="paragraph">
<p>Now comes the fun part, put the first word in <code>d0</code>, this word comes from the previous storage
position. Rotate it, and put it in at the next storage position. Now the extended flag holds the
bit that was shifted out the right, and this one needs to be shifted in on the left in the first
word in the next word cluster. So, a byte offset of 8 (4 words) is added when fetching and
storing the next word. The buffer must also come into play, so the last word will get a byte
offset of 16. Now, we have pre-shifted three words.</p>
</div>
<div class="paragraph">
<p>By adding 2 to both <code>a1</code> and <code>a0</code> we will be at the next bit plane. It will also clear the extended
flag, which is good because otherwise a bit from the last word might come over to the first
word on the next bit plane, which is undesirable. Repeat for all four bit planes. We have now
moved a line of the sprite. After the four bit planes have been rotated, <code>a0</code> and <code>a1</code> will point to
the first word in the second 16 pixel cluster, or 8 bytes from the beginning of the data. By
adding 16, we will point to the next scan line (16+8 = 24). Repeat for 15 positions. Pretty
compact explanation, yes? A graphical representation follows.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="4">Storage area with data, beginning at $0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16 pixels</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">W W W W</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">W W W W</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">W W W W</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">&#8230;&#8203; for 32 lines</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0 2 4 6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8 10 12 14</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16 18 20 22</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">byte offset</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Storage area without data, beginning at <code>$768</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16 pixels</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0 0 0 0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0 0 0 0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0 0 0 0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(each 0 is word size)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">&#8230;&#8203; for 32 lines</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0 2 4 6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8 10 12 14</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16 18 20 22</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">byte offset</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>                ; a0 = $0
                ; a1 = $768

                move.w  (a0), d0
                roxr    d0                       ; C = leftmost bit from W offset 0
                move.w  d0, (a1)                 ; put rotation in 0 at offset 0

                move.w  8(a0), d0                ; as you see, first word of second cluster
                roxr    d0                       ; bit preserved and shifted from offset 0
                move.w  d0, 8(a1)                ; put it at offset 8

                move.w  16(a0), d0               ; first word last cluster
                roxr    d0                       ; rotate, carry bit may now be set
                move.w  d0, 16(a1)               ; at offset 16

                add.l   #2, a0                   ; next bit plane, watch offset
                add.l   #2, a1                   ; also clears X flag</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, <code>a0</code> and <code>a1</code> will both be at offset 8, the first word of the first bit plane, by adding 16 to
this, the offset will be 24, the value for a whole line, effectively putting us at the beginning of
the next line. That concludes the pre-shift of the sprite.</p>
</div>
<div class="paragraph">
<p>The mask data has to be pre-shifted a bit differently. Where the sprite colour is, we need the
mask to be 0, and where the background is, the mask must be 1, as explained above. A look
at the sprite picture will show that the sprite colour area is colour 15, all 1&#8217;s, and the
background is colour 0, all 0&#8217;s. For the mask to be correctly pre-shifted, we need to invert it,
making the background all 1&#8217;s and the sprite colour area all 0&#8217;s. When shifting, we must also
always be shifting in 1&#8217;s, not 0&#8217;s as the case was with the sprite data.</p>
</div>
<div class="paragraph">
<p>The instruction <code>not</code>, for NOT ☺, will take any value and invert it, this means changing all 1&#8217;s
to 0&#8217;s and all 0&#8217;s to 1&#8217;s. In order to have all bits except those concerning the sprite colour
area set, we must make sure to put 1&#8217;s in the buffer area. Also, at the beginning of each
plane loop, we must also make sure that the highest bit of <code>d0</code> is set, so that 1&#8217;s are shifted in.
Other than that, the sprite and mask pre-shift share ideas. The mask area is as big as the
sprite area. Even though this isn&#8217;t necessary since all bit planes in the sprite look alike, we
could have reduced the size by ¾, but for ease of understanding, this was not done.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>                move.l  #spr_dat, a0
                add.l   #34+160*32, a0           ; skip palette and sprite

                move.l  #mask, a1                ; load up mask part

                move.l  #32-1, d0                ; 32 scan lines per sprite
first_mask
                move.l  (a0)+, (a1)              ; move from original to pre-shifted
                not.l   (a1)+                    ; invert the mask data
                move.l  (a0)+, (a1)
                not.l   (a1)+                    ; invert the mask data
                move.l  (a0)+, (a1)
                not.l   (a1)+                    ; invert the mask data
                move.l  (a0)+, (a1)
                not.l   (a1)+                    ; invert the mask data
                move.l  #$ffffffff, (a1)+        ; fill last two words...
                move.l  #$ffffffff, (a1)+        ; ... with all 1's

                add.l   #144, a0                 ; jump to next scan line
                dbf     d0, first_mask
; the picture mask has been copied to first position in pre-shift

                move.l  #mask, a0                ; point to beginning of storage area
                move.l  #mask, a1                ; point to beginning of storage area
                add.l   #768, a1                 ; point to next mask position

                move.l  #15-1, d1                ; 15 sprite positions left
positions_mask
                move.l  #32-1, d2                ; 32 scan lines per sprite
line_mask
                move.l  #4-1, d3                 ; 4 bit planes
plane_mask
                move.w  (a0), d0                 ; move one word
                roxr    #1, d0                   ; pre-shift
                or.w    #%1000000000000000, d0   ; make sure most significant bit set
                move.w  d0, (a1)                 ; put it in place

                move.w  8(a0), d0                ; move one word
                roxr    #1, d0                   ; pre-shift
                move.w  d0, 8(a1)                ; put it in place

                move.w  16(a0), d0               ; move one word
                roxr    #1, d0                   ; pre-shift
                move.w  d0, 16(a1)               ; put it in place

                add.l   #2, a1                   ; next bit plane
                add.l   #2, a0                   ; next plane, clears X flag (bad)

                dbf     d3, plane_mask

                add.l   #16, a1                  ; next scan line
                add.l   #16, a0                  ; next scan line

                dbf     d2, line_mask

                dbf     d1, positions_mask</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the sprite pre-shift where we could set up the storage area with direct memory moves
from the sprite picture to the storage area, here we move data, and then perform the NOT
instruction to invert the data. Also, instead of just skipping the buffer area like in the sprite,
here we fill it with 1&#8217;s. The bit plane loop is almost identical, with the one exception that the
first shift must be guaranteed to shift in a 1, not a 0. A simple OR instruction will make sure
the most significant bit is set. That was that, all pre-shifting done.</p>
</div>
<div class="paragraph">
<p>The method which we use to get the coordinates is the exact one found in Chapter 10. So
when we send in our coordinates, we will be provided with a pointer to the screen address,
and the number of shifts to be done in <code>d0</code>. The number in <code>d0</code> is an offset for the sprite data
and mask data. By putting the address to the sprite data in an address register, multiplying
<code>d0</code> with 768 and adding that to the address register, we will get a pointer to correctly shifted
sprite data. The reason for the number being 768 is that it is the size of a sprite block.</p>
</div>
<div class="paragraph">
<p>OK, now comes the problem of actually moving the sprite. We can put a sprite at any
coordinate we want, but we can&#8217;t move it yet. A simple bounce routine here, the sprite will
move with a certain X speed and a certain Y speed, and change direction when it hits "walls"
(edges of the screen). What we need is a heading, and a speed. For simplicity, we express
the heading as either 1 or 0 for both X and Y respectively. 1 is towards bottom right and 0 is
towards upper left. X heading is either right or left, and Y heading either up or down. The X
and Y speed is how many pixels to move the sprite in desired direction each VBL. So with an
X heading of 1, and an X speed of 2, the sprite would move 2 pixels right each VBL.</p>
</div>
<div class="paragraph">
<p>What the move routine needs to do is to add X and Y coordinates in accordance with heading
and speed, as well as checking for wall hits. When a wall hit occurs, the sprite must change
direction. A change in direction simply means flipping between 1 or 0 in heading. This might
be a good time to tell about the <code>equ</code>, for <strong>EQU</strong>als method. Any label can have an <code>equ</code> applied
to it, meaning that whenever one uses the label, it is replaced by the <code>equ</code>. Easy huh?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>number          equ     2
                move.l  #number, d0              ; same as move.l #2,d0</code></pre>
</div>
</div>
<div class="paragraph">
<p>One can say that <code>equ</code>'s, are constants. It&#8217;s good practice to have as many <code>equ</code>'s as possible,
because if you realize you have to change a constant, you only need to change it in one place
instead of every place the constant appears. X speed and Y speed is a good example (unless
you want variable speed), X coordinate is a terrible thing, since it needs to change all the
time. Actually, I think it&#8217;s best to express the move routine in pseudo code first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>If (x_coord &gt; 319 - 32 - x_speed + 1) Then
        x_heading = 0
If (x_coord &lt; 0) Then
        x_heading = 1
If (y_coord &gt; 199 - 32 - y_speed + 1) Then
        y_heading = 0
If (y_coord &lt; 0) Then
        y_heading = 1</pre>
</div>
</div>
<div class="paragraph">
<p>First we check to see if the heading needs change, as long as the sprite is in any way outside
the screen coordinates, we need to change the heading. Since we check the heading before
we move the sprite, and move the sprite before drawing it, the sprite will never be drawn off
screen. The only trouble here is where all numbers come from. Think of it first without
<code>x_speed</code> added, every VBL the sprite just moves one pixel. Then the formula is <code>x_coord</code> &gt;
319 - 32. This is easy to grasp, the X coordinate must not be more than the screen can hold,
which is 319, minus the width of the sprite itself of course, which is 32.</p>
</div>
<div class="paragraph">
<p>The so called "hot spot" of the sprite is the upper left corner. This is the point against which
all sprite coordinates are measured. We say that the sprite is at coordinates 13,13, but this
really means that the sprite hot spot is at 13,13. Exactly what pixels the sprite inhabits is
unknown to us, since the sprite can have any form, but for simplicity, we think of the sprite
as a square, with the coordinates in the upper left corner. Thus, when seeing if the sprite hits
the right wall, we take the coordinates of the upper left corner, the hot spot, and add the
width of the sprite.</p>
</div>
<div class="paragraph">
<p>The <code>x_speed</code> is also to be taken into account. Imagine the sprite moving with 100 pixels per
VBL, then the sprite will be way outside the screen if it&#8217;s anywhere over the right half of the
screen, so the sprite is only ok if it&#8217;s on the left half of the screen, obviously, the speed must
be taken into account. Think of the speed as just enlargement to the sprite. The Y check
works exactly the same way, but with a different max coordinate for obvious reasons. It looks
a bit different in assembly though.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>                cmp     #319-32-x_speed+1, x_coord

                blt     x_right_ok               ; see if x is &lt; 319-32 for width
                move.w  #0, x_heading            ; if x &gt;=319, change heading
x_right_ok

                cmp     #0, x_coord
                bgt     x_left_ok                ; see if x is &gt; 0
                move.w  #1, x_heading            ; if x &lt;=0, change heading
x_left_ok

                cmp     #199-32-y_speed+1, y_coord
                blt     y_low_ok                 ; see if y is &lt; 199-32 for lines
                move.w  #0, y_heading            ; if y &gt;=199, change heading
y_low_ok

                cmp     #0, y_coord
                bgt     y_high_ok                ; see if y is &gt; 0
                move.w  #1, y_heading            ; if y &lt;=0, change heading
y_high_ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>We check if the X coordinate is lesser than the number, and if it is, it&#8217;s ok and a little branch
will skip the changing of the X heading. Whereas the pseudo code&#8217;s IF statements took place
if the check was true, our checks affect if the statements are false. This may look messy, but
it&#8217;s really quite simple, just take a second look at it. We also need to update the coordinates,
here&#8217;s some more pseudo code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>If (x_heading = 0) Then
        x_coordinate = x_coordinate - x_speed
Else
        x_coordinate = x_coordinate + x_speed

If (y_heading = 0) Then
        y_coordinate = y_coordinate - y_speed
Else
        y_coordinate = y_coordinate + y_speed</pre>
</div>
</div>
<div class="paragraph">
<p>No problem there, just change the coordinates according to speed and heading. In assembly
it becomes more troublesome though.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>                cmp #0, x_heading                ; check x heading
                bne x_move_right                 ; if 1, move right, otherwise left
                sub.w #x_speed, x_coord          ; move sprite left
                bra x_move_done                  ; done moving sprite in x
x_move_right
                add.w #x_speed, x_coord          ; move sprite right
x_move_done

                cmp #0, y_heading                ; check y heading
                bne y_move_down                  ; if 1, move down, otherwise up
                sub.w #y_speed, y_coord          ; move sprite up
                bra y_move_done                  ; done moving sprite in y
y_move_down
                add.w #y_speed, y_coord          ; move sprite down
y_move_done</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, a check to see if X heading is 0, if it is, move to the left, otherwise move to the right. If
we move to the left, we subtract the X coordinate by the X speed, and we must also make
sure to jump past the move to the right. The Y part is exactly as the X part. Again, just look
one more time at the code and if it seems confusing, write it down on paper if you must and
go through the different possible branches, it&#8217;s not too complex once you structuralize it.</p>
</div>
<div class="paragraph">
<p>Hoah, this takes time to explain, hope you&#8217;re still with me 'cus we are almost done. Now we
know how to pre-shift, apply the sprite and move it. One would think that we have all we
need, there is just one more thing to take into account. If we would apply the things we
know and fire away, we would have a sprite that moves over the screen and leaves a trail.</p>
</div>
<div class="paragraph">
<p>The damn thing will never go away, making it most ugly. Why? Because the background must
be restored when the sprite has passed it.</p>
</div>
<div class="paragraph">
<p>So, on every VBL, the background must first be restored, then it must be saved after the
sprite coordinates are updated, since the save and restore routine is dependent on the sprite
coordinates. Then we can paint the sprite. The save routine just copies a sprite sized block
from the screen memory into a save buffer, and the restore routine copies the data from the
buffer onto the screen.</p>
</div>
<div class="paragraph">
<p>What we have now is a main routine that restores background, moves the sprite (rather
updates the sprite coordinates), saves the background, applies the mask and lastly paints the
sprite. All of this is so fast, that we don&#8217;t even have to bother with double buffering, so we
pull a fast one and just skip that. Here comes the entire source code, don&#8217;t panic, most of the
stuff will be familiar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>x_speed         equ     2                         ; how many x coord to move each VBL
y_speed         equ     1                         ; how many y coord to move each VBL

                jsr     initialise

; pre-shifting sprite
                move.l  #spr_dat, a0              ; original sprite data
                add.l   #34, a0                   ; skip palette
                move.l  #sprite, a1               ; storage of pre-shifted sprite

                move.l  #32-1, d0                 ; 32 scan lines per sprite
first_sprite
                move.l  (a0)+, (a1)+              ; move from original to pre-shifted
                move.l  (a0)+, (a1)+
                move.l  (a0)+, (a1)+
                move.l  (a0)+, (a1)+              ; 32 pixels moved
                add.l   #8, a1                    ; jump over end words
                add.l   #144, a0                  ; jump to next scan line
                dbf     d0, first_sprite
; the picture sprite has been copied to first position in pre-shift

                move.l  #sprite, a0               ; point to beginning of storage area
                move.l  #sprite, a1               ; point to beginning of storage area
                add.l   #768, a1                  ; point to next sprite position

                move.l  #15-1, d1                 ; 15 sprite positions left
positions
                move.l  #32-1, d2                 ; 32 scan lines per sprite
line
                move.l  #4-1, d3                  ; 4 bit planes
plane
                move.w  (a0), d0                  ; move one word
                roxr    #1, d0                    ; pre-shift
                move.w  d0, (a1)                  ; put it in place

                move.w  8(a0), d0                 ; move one word
                roxr    #1, d0                    ; pre-shift
                move.w  d0, 8(a1)                 ; put it in place

                move.w  16(a0), d0                ; move one word
                roxr    #1, d0                    ; pre-shift
                move.w  d0, 16(a1)                ; put it in place

                add.l   #2, a0                    ; next bit plane, also clears X flag
                add.l   #2, a1                    ; next bit plane

                dbf     d3, plane

                add.l   #16, a0                   ; next scan line
                add.l   #16, a1                   ; next scan line

                dbf     d2, line

                dbf     d1, positions
; pre-shift of sprite done, all 16 sprite possitions saved in sprite


; pre-shifting mask
                move.l  #spr_dat, a0
                add.l   #34+160*32, a0            ; skip palette and sprite
                move.l  #mask, a1                 ; load up mask part

                move.l  #32-1, d0                 ; 32 scan lines per sprite
first_mask
                move.l  (a0)+, (a1)               ; move from original to pre-shifted
                not.l   (a1)+                     ; invert the mask data
                move.l  (a0)+, (a1)
                not.l   (a1)+                     ; invert the mask data
                move.l  (a0)+, (a1)
                not.l   (a1)+                     ; invert the mask data
                move.l  (a0)+, (a1)               ;
                not.l   (a1)+                     ; invert the mask data
                move.l  #$ffffffff, (a1)+         ;  fill last two words...
                move.l  #$ffffffff, (a1)+         ;  ... with all 1's

                add.l   #144, a0                  ; jump to next scan line
                dbf     d0, first_mask
; the picture mask has been copied to first position in pre-shift

                move.l  #mask, a0                 ; point to beginning of storage area
                move.l  #mask, a1                 ; point to beginning of storage area
                add.l   #768, a1                  ; point to next mask position

                move.l  #15-1, d1                 ; 15 sprite positions left
positions_mask
                move.l  #32-1, d2                 ; 32 scan lines per sprite
line_mask
                move.l  #4-1, d3                  ; 4 bit planes
plane_mask
                move.w  (a0), d0                  ; move one word
                roxr    #1, d0                    ; pre-shift
                or.w    #%1000000000000000, d0    ; make sure most significant bit set
                move.w  d0, (a1)                  ; put it in place

                move.w  8(a0), d0                 ; move one word
                roxr    #1, d0                    ; pre-shift
                move.w  d0, 8(a1)                 ; put it in place

                move.w  16(a0), d0                ; move one word
                roxr    #1, d0                    ; pre-shift
                move.w  d0, 16(a1)                ; put it in place

                add.l   #2, a0                    ; next bit plane, clears X flag (bad)
                add.l   #2, a1                    ; next bit plane

                dbf     d3, plane_mask

                add.l   #16, a0                   ; next scan line
                add.l   #16, a1                   ; next scan line

                dbf     d2, line_mask

                dbf     d1, positions_mask
; pre-shift of mask done, all 16 sprite possitions saved in mask

                movem.l bg+2, d0-d7
                movem.l d0-d7, $ff8240

                move.l  #bg+34, a0                ; pixel part of background
                move.l  $44e, a1                  ; put screen memory in a1
                move.l  #7999, d0                 ; 8000 longwords to a screen
pic_loop
                move.l  (a0)+, (a1)+              ; move one longword to screen
                dbf     d0, pic_loop              ; background painted

                jsr     save_background           ; something in restore buffer

                move.l  $70, old_70               ; backup $70
                move.l  #main, $70                ; put in main routine

                move.w  #7, -(a7)
                trap    #1
                addq.l  #2, a7                    ; wait keypress

                move.l  old_70, $70               ; restore old $70

                jsr     restore

                clr.l   -(a7)
                trap    #1                        ; exit

main
                movem.l d0-d7/a0-a6, -(a7)        ; backup registers

                jsr     restore_background
                jsr     move_sprite
                jsr     save_background
                jsr     apply_mask
                jsr     put_sprite

                movem.l (a7)+, d0-d7/a0-a6        ; restore registers

                rte

move_sprite
; moves the sprite one pixel in x and y
; see if any headings need to be changed
                cmp     #319-32-x_speed+1, x_coord
                blt     x_right_ok                ; see if x is &lt; 319-32 for width
                move.w  #0, x_heading             ; if x &gt;=319, change heading
x_right_ok

                cmp     #0, x_coord
                bgt     x_left_ok                 ; see if x is &gt; 0
                move.w  #1, x_heading             ; if x &lt;=0, change heading
x_left_ok

                cmp     #199-32-y_speed+1, y_coord
                blt     y_low_ok                  ; see if y is &lt; 199-32 for lines
                move.w  #0, y_heading             ; if y &gt;=199, change heading
y_low_ok

                cmp     #0, y_coord
                bgt     y_high_ok                 ; see if y is &gt; 0
                move.w  #1, y_heading             ; if y &lt;=0, change heading
y_high_ok
; all eventual heading changes now made

; move sprite coordinates (change coordinates)
                cmp     #0, x_heading             ; check x heading
                bne     x_move_right              ; if 1, move right, otherwise left
                sub.w   #x_speed, x_coord         ; move sprite left
                bra     x_move_done               ; done moving sprite in x
x_move_right
                add.w   #x_speed, x_coord         ; move sprte right
x_move_done

                cmp     #0, y_heading             ; check y heading
                bne     y_move_down               ; if 1, move down, otherwise up
                sub.w   #y_speed, y_coord         ; move sprite up
                bra     y_move_done               ; done moving sprite in y
y_move_down
                add.w   #y_speed, y_coord         ; move sprte down
y_move_done
; finnished moving sprite

                rts

apply_mask
; applies the mask to the background
                jsr     get_coordinates
                move.l  #mask, a0
                mulu    #768, d0                  ; multiply position with size
                add.l   d0, a0                    ; add value to mask pointer

                move.l  #32-1, d7                 ; mask is 32 scan lines
maskloop
                rept    6                         ; mask is 6*4 bytes width
                move.l  (a0)+, d0                 ; mask data in d0
                move.l  (a1), d1                  ; background data in d1
                and.l   d0, d1                    ; and mask and picture data
                move.l  d1, (a1)+                 ; move masked data to background
                endr
                add.l   #136, a1                  ; next scan line
                dbf     d7, maskloop

                rts

put_sprite
; paints the sprite to the screen
                jsr     get_coordinates
                move.l  #sprite, a0
                mulu    #768, d0                  ; multiply position with size
                add.l   d0, a0                    ; add value to sprite pointer

                move.l  #32-1, d7                 ; sprite is 32 scan lines
bgloop
                rept    6                         ; sprite is 6*4 bytes width
                move.l  (a0)+, d0                 ; sprite data in d0
                move.l  (a1), d1                  ; background data in d1
                or.l    d0, d1                    ; or sprite and background data
                move.l  d1, (a1)+                 ; move ored sprite data to background
                endr
                add.l   #136, a1
                dbf     d7, bgloop

                rts

save_background
; saves the background into bgsave
                jsr     get_coordinates
                move.l  #bgsave, a0

                move.l  #32-1, d7                 ; sprite is 32 scan lines
bgsaveloop
                rept    6                         ; sprite is 6*4 bytes width
                move.l  (a1)+, (a0)+              ; copy background to save buffer
                endr
                add.l   #136, a1                  ; next scan line
                dbf     d7, bgsaveloop

                rts

restore_background
; restores the background using data from bgsave
                jsr     get_coordinates
                move.l  #bgsave, a0

                move.l  #32-1, d7                 ; sprite is 32 scan lines
bgrestoreloop
                rept    6                         ; sprite is 6*4 bytes width
                move.l  (a0)+, (a1)+              ; copy save buffer to background
                endr
                add.l   #136, a1                  ; next scan line
                dbf     d7, bgrestoreloop

                rts

get_coordinates
; makes a1 point to correct place on screen
; sprite position in d0.b
                move.l  $44e, a1                  ; screen memory in a1
                move.w  y_coord, d0               ; put y coordinate in d0
                mulu    #160, d0                  ; 160 bytes to a scan line
                add.l   d0, a1                    ; add to screen pointer
                move.w  x_coord, d0               ; put x coordinate in d0
                divu.w  #16, d0                   ; number of clusters in low, bit in high
                clr.l   d1                        ; clear d1
                move.w  d0, d1                    ; move cluster part to d1
                mulu.w  #8, d1                    ; 8 bytes to a cluster
                add.l   d1, a1                    ; add cluster part to screen memory
                clr.w   d0                        ; clear out the cluster value
                swap    d0                        ; bit to alter in low part of d0

                rts

                include initlib.s

                section data
x_coord         dc.w    0
y_coord         dc.w    0
x_heading       dc.w    1
y_heading       dc.w    1

spr_dat         incbin  sprite.pi1
bg              incbin  autumn.pi1
old_70          dc.l    0

                section bss
sprite          ds.l    3072                      ; 32/2+8*32 bytes 16 positions / 4 for long
mask            ds.l    3072                      ; same as above
bgsave          ds.l    192                       ; 32/2+8*32 bytes / 4 for long</code></pre>
</div>
</div>
<div class="paragraph">
<p>The longest source to date, I&#8217;m truly starting to doubt the wisdom of putting the source code
here as well as in a separate file. Anyways, starting from beginning going down, this is what
it&#8217;s all about. The first two lines are the X and Y speed, you may play around with these
values to your hearts content, of course, setting them both to the same value will make the
sprite move in 45 degrees, while any other values will make the sprite move differently.</p>
</div>
<div class="paragraph">
<p>Then, the pre-shifting of the sprite and the mask, this has been dealt with extensively and
there is nothing more to add. After this, the background is also prepared, it&#8217;s just another
put-degas-file-in-screen-memory. Note here, that there is a background save, this is to make
sure something is in the save buffer before starting the main routine, otherwise the main
routine would start off by "restoring" a blank area, effectively deleting a sprite sized block of
the screen.</p>
</div>
<div class="paragraph">
<p>All preparations are done, just install the main routine, as described in <a href="tutorial-09.html">tutorial 9</a>.
Put our main routine in the <code>$70</code> vector, to have it executed every VBL. Wait for a key press, during
which the main routine will execute continuously, and make a clean exit. Now, take note of
how nice and tidy the main routine is, it just consists of subroutine calls, making the structure
of the program very easy to read, and isolating each major part of the program for ease of
reading.</p>
</div>
<div class="paragraph">
<p>Each subroutine in turn relies upon the <code>get_coordinates</code> routine, which translates the <code>x_coord</code>
and <code>y_coord</code> into data intelligible to the program. As you can see in the comments at the start
of the <code>get_coordinates</code> subroutine, what the routine does is to put a pointer to the screen
memory in <code>a0</code> and the sprite position (offset) in <code>d0.b</code> (meaning the least significant 8 bits of
the <code>d0</code> register). Since each subroutine relies upon the <code>get_coordinates</code> routine, if a bug is
detected in the coordinate routine, it will only have to be dealt with in one place.</p>
</div>
<div class="paragraph">
<p>The save/restore background routines are short and simple and do little. They begin by
calling the get_coordinates routine in order to get a screen pointer, the sprite position is
uninteresting since they both deal with the entire sprite block.</p>
</div>
<div class="paragraph">
<p>The sprite and mask routines are very similar. Both begin by calling the <code>get_coordinates</code>
routine, in order to get a screen pointer and a sprite position. Then either the sprite or mask
area is loaded as appropriate, and the sprite position applied as an offset. Then comes a loop
of moving data from the background and sprite or mask. Then this data is either ANDed or
ORed as appropriate. The result is put back in the screen memory.</p>
</div>
<div class="paragraph">
<p>Well, that is that. I haven&#8217;t gone into everything in minute detail, but by now you shouldn&#8217;t
have to be baby nursed through every operation. The source code has many fun things you
can do with it yourself, so test around some in the critical areas. The obvious change is the
speed change, then, you can try commenting out some things in the main routine, and
change an OR to a MOVE in the sprite routine for example. I think it&#8217;s a good idea to play
around some with the source code, and try to predict the changes, in this way, you&#8217;ll really
understand the underlying mechanics.</p>
</div>
<div class="paragraph">
<p>The next tutorial will probably be a very small one, I&#8217;m even considering of calling it tutorial
11 part B, and might cover the well known "infinite trail" of sprites, since it&#8217;s ridiculously easy.
Somewhere soon I suppose I&#8217;ll do one on joystick and perhaps also mouse operation. I won&#8217;t
promise anything though. Big thanks again go out to Bruno Padinha, for providing valuable
feedback and hitting me on the head. Damn, now I have to think of a good quote as well,
this part is the hardest. ☺</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-10-29 22:52:39 UTC
</div>
</div>
</body>
</html>